## 递归与迭代
```javascript
const f = x => x && f(--x);
```

没有出现任何特殊的语法和运算 / 操作符的，它只是对函数、（变量或常量的）声明、表达式以及函数调用等等的简单组合。



```javascript
// 迭代函数
function foo(x = 5) {
  return {
    next: () => {
      return {done: !x, value: x && x--};
    }
  }
}
```

迭代也是循环语义的一种实现，它说明循环是“函数体”的重复执行，而不是“递归”所理解的“函数调用自己”的语义。这是一种可受用户代码控制的循环体。迭代函数中有“值 (value) 和状态 (done)”两个控制变量。



递归函数“f()”和迭代函数“foo()”其实是在实现相同的过程。只是由于“递归完成与循环过程的结束”在这里是相同的语义，因此函数“f()”中不需要像迭代函数那样来处理“状态 (done)”的传出。递归函数“f()”，要么结束，要么无穷递归。

## 迭代对执行过程的重造和使用
```javascript
let x = new Object;
x[Symbol.iterator] = foo; // default `x` is 5


console.log(...x);
// 5 4 3 2 1
```

## 展开语法
在语义上，它用于“展开一个可迭代对象”。



在 JavaScript 中（也包括在绝大多数支持函数的语言中），函数只能返回一个值。然而，如果迭代器表达的是一个重复执行的执行体，并且每次执行都返回一个值。

## 内部迭代过程
迭代的本质是多次函数调用，在 JavaScript 内部实现这一机制，本质上就是管理这些多次调用之间的关系。这包括一个循环过程，和至少一个循环控制变量。

