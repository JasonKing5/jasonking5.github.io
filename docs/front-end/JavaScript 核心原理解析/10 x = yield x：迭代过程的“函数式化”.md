## 将迭代过程展开
连续的 tor.next() 调用最终仅是为了获取它们的值（result.value），那么如果封装这些值的生成过程，就可以用一个新的函数来替代一批函数。这样的一个函数就称为生成器函数。



函数只有一个出口（RETURN），用“函数的退出”是无法映射“函数包含一个多次生成值的过程”这样的概念。要实现这一点，就必须让函数可以多次进入和退出。

1. 逻辑上：它产生一次函数的退出，并接受下一次 tor.next() 调用所需要的进入；
2. 数据上：它在退出时传出指定的值（结果），并在进入时携带传入的数据（参数）。



yield实际上就是在生成器函数中用较少的代价来实现一个完整“函数执行”过程所需的“参数和结果”。执行体就是 tor.next() 所推动的那个迭代逻辑。

## 逻辑的重现
生成器的关键在于如何产生yield运算所需要的两个逻辑：（函数的）退出和进入。



执行现场包括三个层面的概念：

1. 块级作用域以及其他的作用域本质上就是一帧数据，交由所谓“环境”来管理；
2. 函数是通过 CALL/RETURN 来模拟上述“数据帧”在栈上的入栈与出栈过程，也称为调用栈；
3. 执行现场是上述环境和调用栈的一个瞬时快照（包括栈上数据的状态和执行的“位置”）。

