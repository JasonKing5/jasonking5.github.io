操作系统里的程序并不能直接访问物理内存。

![](https://blog-1252173264.cos.ap-shanghai.myqcloud.com/1648950249453-a87c59f9-a5e3-4960-a0e2-d721bff4746b.png)

## 简单页表

页表（Page Table）：建一张映射表，能够实现虚拟内存里面的页，到物理内存里面的页的一一映射。

把一个内存地址分成页号（Directory）和偏移量（Offset）两个部分。

![](https://blog-1252173264.cos.ap-shanghai.myqcloud.com/1648950613246-d55d4322-ce01-4f5d-b907-2b45c2c00373.png)

内存地址转换：

1. 把虚拟内存地址切分成页号和偏移量的组合；
2. 从页表里面查询出虚拟页号对应的物理页号；
3. 直接拿物理页号加上前面的偏移量，得到物理内存地址。

![](https://blog-1252173264.cos.ap-shanghai.myqcloud.com/1648950821780-60678d6b-5c13-4fd3-b287-4490c5f5313a.png)

占用内容空间大：每个进程都有属于自己独立的虚拟内存地址空间，每个进程都需要这样一个页表，不管这个进程本身只大小的。

## 多级页表

实际程序进程里，虚拟内存占用的地址空间，通常是两段连续的空间。多级页表特别适合这样的内存地址分布。

![](https://blog-1252173264.cos.ap-shanghai.myqcloud.com/1648951244719-842ecda1-d05a-447e-a044-b91802df08bb.png)

![](https://blog-1252173264.cos.ap-shanghai.myqcloud.com/1648951518921-4cf91713-65d8-457e-a82f-f56efac00a6d.png)

多级页表节约了存储空间，却增加了时间开销，是一个以时间换空间的策略。

## 加速地址转换

加缓存把之前的内存转换地址缓存下来，不需要反复去访问内存来进行内存地址转换。

![](https://blog-1252173264.cos.ap-shanghai.myqcloud.com/1648952093963-42bfd3d3-2b19-4fcb-8171-9a04d9972b72.png)

CPU 里的缓存芯片 TLB，全称地址变换高速缓冲（Translation-Lookaside Buffer），存放之前已经进行过地址转换的查询结果。

1. 分成指令的 TLB（ITLB）和数据的 TLB（DTLB）
2. 根据大小分级成 L1、L2 多层的 TLB
3. 用脏标记实现写回缓存管理策略

![](https://blog-1252173264.cos.ap-shanghai.myqcloud.com/1648952396270-c6500b89-5a2d-4755-b57c-3df5540b9f6a.png)

在 CPU 芯片里封装了内存管理单元（MMU，Memory Management Unit）芯片，用来完成地址转换，控制 TLB 的访问和交互。

## 安全性与内存保护

### 可执行空间保护

进程使用的内存，只把其中的指令部分设置成可执行的，其他部分（数据部分）没有可执行的权限。

### 地址空间布局随机化

让进程的内存布局空间的位置不再固定，在内存空间随机分配这些进程里不同部分所在的内存空间地址。
